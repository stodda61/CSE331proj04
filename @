/****************************************************************************
  Craig Stoddard
  A45086748
  CSE331 Project #2
  Binary Search Tree
****************************************************************************/
//#include "bst.h"
#include<iostream>
#include<fstream>
#include<stdio.h>
#include<stdlib.h>
#include<string>
#include<list>

using namespace std; 

struct node {
	int info;
	node *next;
};
/*
class Queue {
	private: 
		//node *front;
		//node *rear;
	public:
		Queue();
		~Queue();
		bool isEmpty();
		void enqueue(int);
		int dequeue();
};

Queue::Queue() {
	front = NULL;
	rear = NULL;
}

Queue::~Queue() {
	delete front;
}

void Queue::enqueue(int data) {
	node *temp = new node();
	temp->info = data;
	temp->next = NULL;
	
	if (front == NULL)
	{
		front = temp;
	}
	
	else
	{
		rear->next = temp;
	}

	rear = temp;
}

int Queue::dequeue() {
	node *temp = new node();
	int value;
	
	if (front == NULL)
	{
		cout << "\nQueue is Empty\n";
	}

	else
	{
		temp = front;
		value = temp->info;
		front = front->next;
		delete temp;
	}
	return value;
}

bool Queue::isEmpty() {
	return (front == NULL);
}

*/
class Graph {
	private:
		int v; //v is number of vertices in graph
		//int **A; // A stores the edges between two vertices
		list<int> *adj;
	public:
		Graph(int size = 2);
//		~Graph();
		//bool isConnected(int, int);
		void addEdge(int u, int v);
		void BFS(int);
};

Graph::Graph(int v) {
	this->v = v;
	adj = new list<int>[v];
}
	/*	int i;
	int j;
	if (size < 2) 
	{
		n = 2;
	}
	else 
	{
		n = size;
	}
	A = new int*[n];
	for (i = 0; i < n; i++)
	{
		A[i] = new int[n];
	}
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < n; j++)
		{
			A[i][j] = 0;
		}
	}
	cout << "graph created" << endl;
*/
//}

//Graph::~Graph() {
//	for (int i = 0; i < n; i++)
//	{
//		delete [] A[i];
//	}
	
//	delete [] A;
//}

//bool Graph::isConnected(int u, int v) {
//	return (A[u-1][v-1] == 1);
//}

void Graph::addEdge(int u, int v) {
//	A[u-1][v-1] = A[v-1][u-1] = 1;
	adj[u].push_back(v);
}

void Graph::BFS(int s) {
	bool *visited = new bool[v];
	cout << "BFS" << endl;
	for (int i = 0; i <= v; i++)
	{
		visited[i] = false;
	}


	list<int> queue;

	visited[s] = true;
	queue.push_back(s);
	list<int>::iterator i;

	while (!queue.empty())
	{
		s = queue.front();
		cout << s << " ";
		queue.pop_front();
		
		for (i = adj[s].begin(); i != adj[s].end(); i++)
		{
			if(!visited[*i])
			{
				visited[*i] = true;
				queue.push_back(*i);
			}
		}
	}
	cout << endl;
}

//main function, takes and converts the input file
//to ints and then creates nodes out of them
int main(int argc, char * argv[])
{
	fstream input(argv[1], ios::in);
	char ch;
	string buffer;
	string ch1 = argv[2];
	int nodeStart = atoi(ch1.c_str());
	cout << "starting node: " << nodeStart << endl;
	int numcount = 0;
	int numNodes;
	int parent;
	ch = input.get();
	buffer += ch;
	numNodes = atoi(buffer.c_str());
	cout << "Number of Nodes: " << numNodes << endl;
	buffer.clear();
	Graph graph(numNodes);

	while(!input.eof())
	{
		ch = input.get();
		if (isdigit(ch))
		{
			buffer += ch;
			
		}
		else if (ch == ' ')
		{
			int number = atoi(buffer.c_str());
			buffer.clear();
			graph.addEdge(parent, number);
			cout << number << endl;
		}
		else if (ch == ':') 
		{
			parent = atoi(buffer.c_str());
			cout << "Reached Colon with parent: " << parent << endl;
			buffer.clear();
		}
		else if (ch == '\n' && !buffer.empty() )
		{
			int number = atoi(buffer.c_str());
			cout << number << endl;
			buffer.clear();
			graph.addEdge(parent, number);
		}

	}

	if (input.eof() && buffer.empty())
	{
		cout << "parent: " << parent << endl;
		//graph.addEdge(4,4);
	}

	if (input.eof() && !buffer.empty())
	{
		int number = atoi(buffer.c_str());
		cout << "parent: " << parent << endl;
		cout << "number: " << number << endl;
	//	graph.addEdge(parent, number);
	}

	graph.BFS(nodeStart);
		
	/*
	string buffer;
	BSTTree* tree = new BSTTree();
	
	while(!input.eof())
	{
		ch = input.get();
		if (isdigit(ch))
		{
			buffer += ch;
		}
		else if (ch == ' ')
		{
			int number = atoi(buffer.c_str());
			buffer.clear();
			tree->Insert(number);
		}
		else if (ch == '\n' && !buffer.empty())
		{
			int number = atoi(buffer.c_str());
			buffer.clear();
			tree->Insert(number);
		}
	}

	input.close();

	tree->Print();
	
	delete tree;
*/
	return 0;
}


